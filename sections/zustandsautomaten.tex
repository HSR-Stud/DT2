\section{Endliche Zustandsautomaten, Finite State Machine}
\subsection{Grundlegende Eigenschaften}
Eine FMS ist ein Geschlossenes Modell mit einer endlichen Anzahl von Zuständen,
Zustandsübergängen und Aktionen.\\
\textbf{Sinn:} Mathematische Abstraktion, Grundlage theoretischer
Betrachtungen, Ausgangspunkt systematischer praktischer Realisierung.\\
\textbf{Anweundungen:} Informatik (Parser, Compiler, Game)\\
Technik, digitale Schaltungen (Kaffee-Automat, Parkticket, \ldots)\\
Kommunikationstechnik (Protokolldesign)\\
  \subsubsection{Grundstruktur}
  \begin{multicols}{3}
    \includegraphics[width=0.2\textwidth]{pics/fsm_grundlage}
    \textbf{Kombinatorische Logik F/G}\\
    Generiert Ausgänge\\ und Folgezustand.\\
    F = Funktion für Ausgänge\\
    G = Funktion für Speicheransteuerung\\
    \textbf{Zustandsregister Z}\\
    Z = Zustansspeicher/register\\
    Sequentieller Teil des Systems,\\
    speichert aktuellen Zustand.\\
    \textbf{Signale}\\
    x = Eingangsvektor\\
    m = Anzahl Eingänge\\
    y = Ausgangsvektor\\
    n = Anzahl Ausgänge\\
    s = Zustandsvektor\\
    d = Folgezustand\\
    \textbf{Memory}\\
    k = Anzahl Speicherstellen\\
    
  \end{multicols}
  %Bild V4F7
\subsection{Mealy, Moore und Medwedjew}
\begin{tabular}{|p{6cm}|p{6cm}|p{6cm}|}
  \hline
  \textbf{Mealy-System} & \textbf{Moore-System} & \textbf{Medwedjew-System} \\
  \hline
  Grundsystem; komb. Logik F/G in zwei separate Blöcke aufgeteilt & Wert der
  primären Ausgänge ist nur vom aktuellen Zustand des Systems abhängig. &
  Spezialfall des Moore-Systems: Primäre Ausgänge entsprechen dem Zustandsvektor \\
  \hline
  \includegraphics[width=0.3\textwidth]{pics/fsm_mealy} &
  \includegraphics[width=0.3\textwidth]{pics/fsm_moore} &
  \includegraphics[width=0.3\textwidth]{pics/fsm_medwedjew} \\
  \hline
  Ausgänge hängen vom momentanen Zustand und den aktuellen Eingängen ab.
  & Ausgänge hängen nur vom momentanen Zustand ab und ändern mit der
  Clock-Flanke. & Die primären Ausgänge entsprechen dem Zustandsvektor.
  Ausgangsfunktion F degeneriert auf 1. \\
  \hline
  $ y[i] = F(x[i],x[i]) $ & $ y[i] = F(s[i]) $ & $ y[i] = s[i] := G(x[i-1],y[i-1]) $ \\
  $ d[i] = s[i+1] := G(x[i],s[i]) $ & $ d[i]=s[i+1] := G(x[i],s[i]) $ & $ 
  s[i+1]:=G(x[i],s[i])$ \\
  \hline
  Die Ausgabe ändert unabhängig vom Clock. Sequentielle Komposition erzeugt
  lange Signalpfade. Dadurch kann es zu Races und Hazards kommen. Längste Pfade
  sind invers proportional zu erzielbaren Taktfrequenzen. & Allgemeiner
  Prototyp eines synchronen, sequentiellen Entwurfes. Verzögerung Latenzzeit
  (das berechnete Ergebnis wird erst im nächsten Takt weitergegeben). Dadurch
  sind Signallaufzeiten viel besser kontrollierbar. & Ausgänge
  entsprechen den Zuständen. Zustände müssen gleich codiert werden wie
  Ausgangssignale.\\
  \hline
  
  Mausefalle & Menüstrukur & Die meisten Counter \\
  \hline
  \lstinputlisting[language=VHDL,tabsize=2]{code/fsm_mealy.vhdl} &
  \lstinputlisting[language=VHDL,tabsize=2]{code/fsm_moore.vhdl} &
  \lstinputlisting[language=VHDL,tabsize=2]{code/fsm_medwedjew.vhdl} \\
  \hline
\end{tabular}

\subsection{Code Umsetzung der einzelnen Blöcke}
  \begin{multicols}{2}
  
  
    \subsubsection{F: OutputLogic}
    	\lstinputlisting[language=VHDL,tabsize=2]{code/fsm_f.vhdl}
    \subsubsection{Z: RegisterLogic}
    	\lstinputlisting[language=VHDL,tabsize=2]{code/fsm_z.vhdl}
  \end{multicols}
  \subsubsection{G: NextStateLogic}
  \lstinputlisting[language=VHDL,tabsize=2]{code/fsm_g.vhdl}
  
  
\subsection{Synthese von Hand}  
Anhand der folgenden Regeln lässt sich ein sequentielles System systematisch von Hand synthetisieren.
\begin{enumerate}
  \setlength{\itemsep}{1pt}
  \setlength{\parskip}{0pt}
  \setlength{\parsep}{0pt}
  \item Zustandsdiagramm aufstellen (siehe \ref{statediagramm})
  \item Zustandskodierung zuweisen (siehe \ref{zustandcodes})
  \item Zustandstabelle nach festen Regeln aufstellen (siehe
  \ref{zustandstabelle})
  \item Speicheransteuer-Funktionen bestimmen 
  \item Ausgangsfunktionen bestimmen
\end{enumerate}
\subsection{Taktfrequenz}
  Die maximale Taktfrequenz wird durch den längsten Pfad zwischen zwei D-FF
  bestimmt. In kaskadierten Systemen kann die zeitliche Situation lokal
  betrachtet werden.\\
  Maximale Taktfrequenz: $f_{clkMax}=\frac{1}{t_{längster Pfad}}$\\
  \textbf{Pipelining} Durch das Einfügen von zusätzlichen FF verkürzt man den
  längsten Pfad, dadurch wird $f_{clkMax} $ grösser, gleichzeitig wird $T_{tot}
  $ (Latency) grösser.
  \subsubsection{Bestimmung des kritischen Pfades}
    \begin{enumerate}
      \setlength{\itemsep}{1pt}
      \setlength{\parskip}{0pt}
      \setlength{\parsep}{0pt}
      \item Die Eingänge der Schaltung mit 0 beschriften.
      \item Für alle Gatter, deren Eingänge beschriftet sind den Ausgang des
      Gatters mit $ max\{Eing\"ange\}+t_p $ (Propagation delay) beschriften.
      \item Sind noch unbeschriftete Ausgangsleitungen vorhanden, dann nochmals
      2 Durchführen.
      \item Die Länge des längsten Pfades ist $max\{Ausg"ange\}$
    \end{enumerate}
    
  \subsubsection{Längster Pfad in Mealy}
    
  \subsubsection{Längster Pfad in Moore}
    Propagation Delay der FF + Längster Pfad von F und G + Setup der FF
   
\subsection{Vermeidung von Hazards}
  Hazards sind kurzzeitige Falschaussagen in logischen Schaltungen. Sie treten
  auf durch unterschiedliche Signallaufzeiten in den einzelnen Gattern und wegen
  unterschiedlicher Anzahl Gatter in Signalwegen. Sie führen zu timing
  Problemen, können fatale Folgen haben und sind ein Problem beim
  Stromverbrauch.\\
  \textbf{Statischer Hazard} Ausgang sollte nicht ändern, ändert aber
  kurzzeitig.\\
  \textbf{Dynamischer Hazard} Ausgang ändert mehrmals bis er stabil wird.\\
  \textbf{Symptombehandlung} Nachgeschaltete Flip-Flops, die die Ausgänge
  Synchronisieren (sichere Methode) oder Ausgleich der Verzögerungszeiten
  (unsichere Methode).\\
  \textbf{Ursachenbehandlung} Elimination des Effektes durch redundante Blöcke.
  
  %Synthese: Sie können die Logikfunktionen und Komponenten bestimmen, welche
  %zur Realisierung von Zustandsautomaten benötigt werden.
  

